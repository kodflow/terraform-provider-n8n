#!/usr/bin/env node

/**
 * Generate a MEGA workflow with ALL 296 nodes
 * Instead of 296 separate workflows, create ONE workflow with all nodes connected
 */

const fs = require('fs');
const path = require('path');

// Configuration
const NODES_DIR = path.join(__dirname, '../../examples/nodes');
const OUTPUT_DIR = path.join(__dirname, '../../examples/mega-workflow');

// Helper to find all main.tf files
function findAllNodeExamples(dir) {
  const examples = [];

  function walk(currentDir) {
    const files = fs.readdirSync(currentDir);

    for (const file of files) {
      const fullPath = path.join(currentDir, file);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory()) {
        walk(fullPath);
      } else if (file === 'main.tf') {
        const category = path.basename(path.dirname(path.dirname(fullPath)));
        const nodeName = path.basename(path.dirname(fullPath));
        examples.push({
          category,
          nodeName,
          path: fullPath
        });
      }
    }
  }

  walk(dir);
  return examples;
}

// Parse Terraform file to extract node info
function parseNodeInfo(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');

  // Extract node type from comment "# Type: n8n-nodes-base.xxx"
  const typeMatch = content.match(/# Type: (n8n-nodes-base\.\w+)/);
  const nodeType = typeMatch ? typeMatch[1] : null;

  // Extract test_node resource
  const testNodeMatch = content.match(/resource "n8n_workflow_node" "test_node" \{[\s\S]*?\n\}/m);
  if (!testNodeMatch) {
    console.warn(`âš ï¸  No test_node found in ${filePath}`);
    return null;
  }

  const testNodeBlock = testNodeMatch[0];

  // Extract name
  const nameMatch = testNodeBlock.match(/name\s*=\s*"([^"]+)"/);
  const nodeName = nameMatch ? nameMatch[1] : 'Unknown';

  // Extract type
  const typeBlockMatch = testNodeBlock.match(/type\s*=\s*"([^"]+)"/);
  const type = typeBlockMatch ? typeBlockMatch[1] : nodeType;

  // Extract parameters (if any)
  const paramsMatch = testNodeBlock.match(/parameters\s*=\s*jsonencode\(([\s\S]*?)\n\s*\)/);
  let parameters = null;
  if (paramsMatch) {
    try {
      // Remove comments and clean up the parameters
      const paramsStr = paramsMatch[1]
        .split('\n')
        .map(line => line.trim())
        .filter(line => !line.startsWith('//') && !line.startsWith('#'))
        .join('\n');

      // Try to extract the JSON object
      const jsonMatch = paramsStr.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        parameters = jsonMatch[0];
      }
    } catch (e) {
      console.warn(`âš ï¸  Could not parse parameters for ${nodeName}:`, e.message);
    }
  }

  return {
    name: nodeName,
    type,
    parameters
  };
}

// Generate Terraform configuration for mega workflow
function generateMegaWorkflow(examples) {
  console.log(`\nðŸ“¦ Generating mega workflow with ${examples.length} nodes...\n`);

  const nodes = [];
  const nodeResources = [];
  const connections = [];
  const connectionResources = [];

  // Track categories
  const categoryCounts = { core: 0, integration: 0, trigger: 0 };

  // Parse all examples and extract node info
  for (const example of examples) {
    const info = parseNodeInfo(example.path);
    if (!info) continue;

    categoryCounts[example.category]++;

    // Create unique resource name
    const resourceName = `node_${example.category}_${example.nodeName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}`;

    nodes.push({
      resourceName,
      info,
      category: example.category,
      nodeName: example.nodeName
    });
  }

  console.log(`ðŸ“Š Node distribution:`);
  console.log(`   - Core: ${categoryCounts.core}`);
  console.log(`   - Integration: ${categoryCounts.integration}`);
  console.log(`   - Trigger: ${categoryCounts.trigger}`);
  console.log(`   - Total: ${nodes.length}\n`);

  // Calculate grid layout (nodes arranged in a grid)
  const COLS = 10; // 10 nodes per row
  const X_SPACING = 250;
  const Y_SPACING = 200;
  const START_X = 250;
  const START_Y = 100;

  // Generate node resources
  let tfContent = `# MEGA Workflow - All ${nodes.length} Nodes
# Auto-generated by generate-mega-workflow.js

terraform {
  required_providers {
    n8n = {
      source  = "kodflow/n8n"
      version = "~> 1.0"
    }
  }
}

provider "n8n" {
  base_url = var.n8n_base_url
  api_key  = var.n8n_api_key
}

# ============================================================================
# START: Manual Trigger
# ============================================================================

resource "n8n_workflow_node" "start_trigger" {
  name     = "Start"
  type     = "n8n-nodes-base.manualTrigger"
  position = [${START_X}, ${START_Y}]
}

# ============================================================================
# ALL NODES (${nodes.length} nodes)
# ============================================================================

`;

  // Generate all node resources
  for (let i = 0; i < nodes.length; i++) {
    const node = nodes[i];
    const col = (i + 1) % COLS;
    const row = Math.floor((i + 1) / COLS);
    const x = START_X + (col * X_SPACING);
    const y = START_Y + (row * Y_SPACING) + Y_SPACING; // +Y_SPACING to account for trigger

    tfContent += `# ${i + 1}. ${node.category}/${node.nodeName} - ${node.info.type}\n`;
    tfContent += `resource "n8n_workflow_node" "${node.resourceName}" {\n`;
    tfContent += `  name     = "${node.info.name}"\n`;
    tfContent += `  type     = "${node.info.type}"\n`;
    tfContent += `  position = [${x}, ${y}]\n`;

    if (node.info.parameters) {
      tfContent += `\n  parameters = jsonencode(\n`;
      tfContent += `    ${node.info.parameters}\n`;
      tfContent += `  )\n`;
    }

    tfContent += `}\n\n`;
  }

  // Add end node
  tfContent += `# ============================================================================
# END: Display Result
# ============================================================================

resource "n8n_workflow_node" "end_result" {
  name     = "End - All Nodes Tested"
  type     = "n8n-nodes-base.set"
  position = [${START_X}, ${START_Y + ((Math.floor(nodes.length / COLS) + 2) * Y_SPACING)}]

  parameters = jsonencode({
    mode = "manual"
    fields = {
      values = [{
        name  = "total_nodes_tested"
        type  = "number"
        value = ${nodes.length}
      }, {
        name  = "completion_message"
        type  = "string"
        value = "Successfully tested all ${nodes.length} nodes!"
      }]
    }
  })
}

# ============================================================================
# CONNECTIONS (${nodes.length + 1} connections)
# ============================================================================

# Start â†’ First Node
resource "n8n_workflow_connection" "start_to_first" {
  source_node         = n8n_workflow_node.start_trigger.name
  source_output       = "main"
  source_output_index = 0
  target_node         = n8n_workflow_node.${nodes[0].resourceName}.name
  target_input        = "main"
  target_input_index  = 0
}

`;

  // Connect all nodes in sequence
  for (let i = 0; i < nodes.length - 1; i++) {
    const current = nodes[i];
    const next = nodes[i + 1];

    tfContent += `# ${i + 1}. ${current.nodeName} â†’ ${next.nodeName}\n`;
    tfContent += `resource "n8n_workflow_connection" "conn_${i}" {\n`;
    tfContent += `  source_node         = n8n_workflow_node.${current.resourceName}.name\n`;
    tfContent += `  source_output       = "main"\n`;
    tfContent += `  source_output_index = 0\n`;
    tfContent += `  target_node         = n8n_workflow_node.${next.resourceName}.name\n`;
    tfContent += `  target_input        = "main"\n`;
    tfContent += `  target_input_index  = 0\n`;
    tfContent += `}\n\n`;
  }

  // Last node â†’ End
  tfContent += `# Last Node â†’ End\n`;
  tfContent += `resource "n8n_workflow_connection" "last_to_end" {\n`;
  tfContent += `  source_node         = n8n_workflow_node.${nodes[nodes.length - 1].resourceName}.name\n`;
  tfContent += `  source_output       = "main"\n`;
  tfContent += `  source_output_index = 0\n`;
  tfContent += `  target_node         = n8n_workflow_node.end_result.name\n`;
  tfContent += `  target_input        = "main"\n`;
  tfContent += `  target_input_index  = 0\n`;
  tfContent += `}\n\n`;

  // Generate nodes_json array
  tfContent += `# ============================================================================
# WORKFLOW
# ============================================================================

resource "n8n_workflow" "mega_workflow" {
  name   = "MEGA Workflow - All ${nodes.length} Nodes"
  active = false

  nodes_json = jsonencode([
    jsondecode(n8n_workflow_node.start_trigger.node_json),
`;

  for (const node of nodes) {
    tfContent += `    jsondecode(n8n_workflow_node.${node.resourceName}.node_json),\n`;
  }

  tfContent += `    jsondecode(n8n_workflow_node.end_result.node_json)
  ])

  connections_json = jsonencode({
    (n8n_workflow_node.start_trigger.name) = {
      main = [[{
        node  = n8n_workflow_node.${nodes[0].resourceName}.name
        type  = "main"
        index = 0
      }]]
    }
`;

  // Add all intermediate connections
  for (let i = 0; i < nodes.length - 1; i++) {
    const current = nodes[i];
    const next = nodes[i + 1];

    tfContent += `    (n8n_workflow_node.${current.resourceName}.name) = {\n`;
    tfContent += `      main = [[{\n`;
    tfContent += `        node  = n8n_workflow_node.${next.resourceName}.name\n`;
    tfContent += `        type  = "main"\n`;
    tfContent += `        index = 0\n`;
    tfContent += `      }]]\n`;
    tfContent += `    }\n`;
  }

  // Last node connection
  tfContent += `    (n8n_workflow_node.${nodes[nodes.length - 1].resourceName}.name) = {\n`;
  tfContent += `      main = [[{\n`;
  tfContent += `        node  = n8n_workflow_node.end_result.name\n`;
  tfContent += `        type  = "main"\n`;
  tfContent += `        index = 0\n`;
  tfContent += `      }]]\n`;
  tfContent += `    }\n`;

  tfContent += `  })
}

# ============================================================================
# OUTPUTS
# ============================================================================

output "workflow_id" {
  value       = n8n_workflow.mega_workflow.id
  description = "ID of the mega workflow"
}

output "workflow_name" {
  value       = n8n_workflow.mega_workflow.name
  description = "Name of the mega workflow"
}

output "total_nodes" {
  value       = ${nodes.length + 2}
  description = "Total number of nodes (including start and end)"
}
`;

  return { tfContent, nodeCount: nodes.length };
}

// Main execution
function main() {
  console.log('ðŸš€ Generating MEGA Workflow with ALL nodes\n');
  console.log('â”'.repeat(80));

  // Find all node examples
  console.log(`\nðŸ“ Scanning ${NODES_DIR}...`);
  const examples = findAllNodeExamples(NODES_DIR);
  console.log(`âœ“ Found ${examples.length} node examples\n`);

  // Generate mega workflow
  const { tfContent, nodeCount } = generateMegaWorkflow(examples);

  // Create output directory
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  // Write main.tf
  const mainTfPath = path.join(OUTPUT_DIR, 'main.tf');
  fs.writeFileSync(mainTfPath, tfContent);
  console.log(`âœ“ Generated ${mainTfPath}`);

  // Write variables.tf
  const variablesTf = `variable "n8n_base_url" {
  description = "N8N instance URL"
  type        = string
}

variable "n8n_api_key" {
  description = "N8N API key"
  type        = string
  sensitive   = true
}
`;

  const variablesTfPath = path.join(OUTPUT_DIR, 'variables.tf');
  fs.writeFileSync(variablesTfPath, variablesTf);
  console.log(`âœ“ Generated ${variablesTfPath}`);

  // Write README
  const readmeMd = `# MEGA Workflow - All ${nodeCount} Nodes

This is an auto-generated Terraform configuration that creates a SINGLE workflow containing ALL ${nodeCount} nodes.

## Structure

- **1 Manual Trigger** (start)
- **${nodeCount} Test Nodes** (connected sequentially)
- **1 Display Result** (end)

Total: ${nodeCount + 2} nodes connected in a chain.

## Usage

\`\`\`bash
# Initialize Terraform
terraform init

# Plan
terraform plan -var="n8n_base_url=\${N8N_API_URL}" -var="n8n_api_key=\${N8N_API_KEY}"

# Apply
terraform apply -var="n8n_base_url=\${N8N_API_URL}" -var="n8n_api_key=\${N8N_API_KEY}" -auto-approve

# Destroy
terraform destroy -var="n8n_base_url=\${N8N_API_URL}" -var="n8n_api_key=\${N8N_API_KEY}" -auto-approve
\`\`\`

## Benefits

- **Single test**: Instead of running 296 separate terraform apply/destroy cycles
- **Fast**: Only 1 plan/apply/destroy for all nodes
- **Real workflow**: Tests all nodes as they would be used in production
- **Connection testing**: Verifies that nodes can be connected properly

## Generated by

\`scripts/nodes/generate-mega-workflow.js\`
`;

  const readmePath = path.join(OUTPUT_DIR, 'README.md');
  fs.writeFileSync(readmePath, readmeMd);
  console.log(`âœ“ Generated ${readmePath}`);

  console.log('\nâ”'.repeat(80));
  console.log(`\nâœ… MEGA Workflow generated successfully!`);
  console.log(`\nðŸ“Š Summary:`);
  console.log(`   - Total nodes: ${nodeCount + 2} (${nodeCount} test nodes + start + end)`);
  console.log(`   - Output directory: ${OUTPUT_DIR}`);
  console.log(`\nðŸš€ Next steps:`);
  console.log(`   cd ${OUTPUT_DIR}`);
  console.log(`   terraform init`);
  console.log(`   terraform plan -var="n8n_base_url=\${N8N_API_URL}" -var="n8n_api_key=\${N8N_API_KEY}"`);
  console.log(`   terraform apply -var="n8n_base_url=\${N8N_API_URL}" -var="n8n_api_key=\${N8N_API_KEY}" -auto-approve`);
  console.log('');
}

// Run
main();
