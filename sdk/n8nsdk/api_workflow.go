/*
n8n Public API

n8n Public API

API version: 1.1.1
Contact: hello@n8n.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package n8nsdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type WorkflowAPI interface {

	/*
		WorkflowsGet Retrieve all workflows

		Retrieve all workflows from your instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return WorkflowAPIWorkflowsGetRequest
	*/
	WorkflowsGet(ctx context.Context) WorkflowAPIWorkflowsGetRequest

	// WorkflowsGetExecute executes the request
	//  @return WorkflowList
	WorkflowsGetExecute(r WorkflowAPIWorkflowsGetRequest) (*WorkflowList, *http.Response, error)

	/*
		WorkflowsIdActivatePost Activate a workflow

		Active a workflow.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the workflow.
		@return WorkflowAPIWorkflowsIdActivatePostRequest
	*/
	WorkflowsIdActivatePost(ctx context.Context, id string) WorkflowAPIWorkflowsIdActivatePostRequest

	// WorkflowsIdActivatePostExecute executes the request
	//  @return Workflow
	WorkflowsIdActivatePostExecute(r WorkflowAPIWorkflowsIdActivatePostRequest) (*Workflow, *http.Response, error)

	/*
		WorkflowsIdDeactivatePost Deactivate a workflow

		Deactivate a workflow.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the workflow.
		@return WorkflowAPIWorkflowsIdDeactivatePostRequest
	*/
	WorkflowsIdDeactivatePost(ctx context.Context, id string) WorkflowAPIWorkflowsIdDeactivatePostRequest

	// WorkflowsIdDeactivatePostExecute executes the request
	//  @return Workflow
	WorkflowsIdDeactivatePostExecute(r WorkflowAPIWorkflowsIdDeactivatePostRequest) (*Workflow, *http.Response, error)

	/*
		WorkflowsIdDelete Delete a workflow

		Deletes a workflow.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the workflow.
		@return WorkflowAPIWorkflowsIdDeleteRequest
	*/
	WorkflowsIdDelete(ctx context.Context, id string) WorkflowAPIWorkflowsIdDeleteRequest

	// WorkflowsIdDeleteExecute executes the request
	//  @return Workflow
	WorkflowsIdDeleteExecute(r WorkflowAPIWorkflowsIdDeleteRequest) (*Workflow, *http.Response, error)

	/*
		WorkflowsIdGet Retrieves a workflow

		Retrieves a workflow.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the workflow.
		@return WorkflowAPIWorkflowsIdGetRequest
	*/
	WorkflowsIdGet(ctx context.Context, id string) WorkflowAPIWorkflowsIdGetRequest

	// WorkflowsIdGetExecute executes the request
	//  @return Workflow
	WorkflowsIdGetExecute(r WorkflowAPIWorkflowsIdGetRequest) (*Workflow, *http.Response, error)

	/*
		WorkflowsIdPut Update a workflow

		Update a workflow.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the workflow.
		@return WorkflowAPIWorkflowsIdPutRequest
	*/
	WorkflowsIdPut(ctx context.Context, id string) WorkflowAPIWorkflowsIdPutRequest

	// WorkflowsIdPutExecute executes the request
	//  @return Workflow
	WorkflowsIdPutExecute(r WorkflowAPIWorkflowsIdPutRequest) (*Workflow, *http.Response, error)

	/*
		WorkflowsIdTagsGet Get workflow tags

		Get workflow tags.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the workflow.
		@return WorkflowAPIWorkflowsIdTagsGetRequest
	*/
	WorkflowsIdTagsGet(ctx context.Context, id string) WorkflowAPIWorkflowsIdTagsGetRequest

	// WorkflowsIdTagsGetExecute executes the request
	//  @return []Tag
	WorkflowsIdTagsGetExecute(r WorkflowAPIWorkflowsIdTagsGetRequest) ([]Tag, *http.Response, error)

	/*
		WorkflowsIdTagsPut Update tags of a workflow

		Update tags of a workflow.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the workflow.
		@return WorkflowAPIWorkflowsIdTagsPutRequest
	*/
	WorkflowsIdTagsPut(ctx context.Context, id string) WorkflowAPIWorkflowsIdTagsPutRequest

	// WorkflowsIdTagsPutExecute executes the request
	//  @return []Tag
	WorkflowsIdTagsPutExecute(r WorkflowAPIWorkflowsIdTagsPutRequest) ([]Tag, *http.Response, error)

	/*
		WorkflowsIdTransferPut Transfer a workflow to another project.

		Transfer a workflow to another project.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param id The ID of the workflow.
		@return WorkflowAPIWorkflowsIdTransferPutRequest
	*/
	WorkflowsIdTransferPut(ctx context.Context, id string) WorkflowAPIWorkflowsIdTransferPutRequest

	// WorkflowsIdTransferPutExecute executes the request
	WorkflowsIdTransferPutExecute(r WorkflowAPIWorkflowsIdTransferPutRequest) (*http.Response, error)

	/*
		WorkflowsPost Create a workflow

		Create a workflow in your instance.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return WorkflowAPIWorkflowsPostRequest
	*/
	WorkflowsPost(ctx context.Context) WorkflowAPIWorkflowsPostRequest

	// WorkflowsPostExecute executes the request
	//  @return Workflow
	WorkflowsPostExecute(r WorkflowAPIWorkflowsPostRequest) (*Workflow, *http.Response, error)
}

// WorkflowAPIService WorkflowAPI service
type WorkflowAPIService service

type WorkflowAPIWorkflowsGetRequest struct {
	ctx               context.Context
	ApiService        WorkflowAPI
	active            *bool
	tags              *string
	name              *string
	projectId         *string
	excludePinnedData *bool
	limit             *float32
	cursor            *string
}

func (r WorkflowAPIWorkflowsGetRequest) Active(active bool) WorkflowAPIWorkflowsGetRequest {
	r.active = &active
	return r
}

func (r WorkflowAPIWorkflowsGetRequest) Tags(tags string) WorkflowAPIWorkflowsGetRequest {
	r.tags = &tags
	return r
}

func (r WorkflowAPIWorkflowsGetRequest) Name(name string) WorkflowAPIWorkflowsGetRequest {
	r.name = &name
	return r
}

func (r WorkflowAPIWorkflowsGetRequest) ProjectId(projectId string) WorkflowAPIWorkflowsGetRequest {
	r.projectId = &projectId
	return r
}

// Set this to avoid retrieving pinned data
func (r WorkflowAPIWorkflowsGetRequest) ExcludePinnedData(excludePinnedData bool) WorkflowAPIWorkflowsGetRequest {
	r.excludePinnedData = &excludePinnedData
	return r
}

// The maximum number of items to return.
func (r WorkflowAPIWorkflowsGetRequest) Limit(limit float32) WorkflowAPIWorkflowsGetRequest {
	r.limit = &limit
	return r
}

// Paginate by setting the cursor parameter to the nextCursor attribute returned by the previous request&#39;s response. Default value fetches the first \&quot;page\&quot; of the collection. See pagination for more detail.
func (r WorkflowAPIWorkflowsGetRequest) Cursor(cursor string) WorkflowAPIWorkflowsGetRequest {
	r.cursor = &cursor
	return r
}

func (r WorkflowAPIWorkflowsGetRequest) Execute() (*WorkflowList, *http.Response, error) {
	return r.ApiService.WorkflowsGetExecute(r)
}

/*
WorkflowsGet Retrieve all workflows

Retrieve all workflows from your instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return WorkflowAPIWorkflowsGetRequest
*/
func (a *WorkflowAPIService) WorkflowsGet(ctx context.Context) WorkflowAPIWorkflowsGetRequest {
	return WorkflowAPIWorkflowsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WorkflowList
func (a *WorkflowAPIService) WorkflowsGetExecute(r WorkflowAPIWorkflowsGetRequest) (*WorkflowList, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WorkflowList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "form", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.projectId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "projectId", r.projectId, "form", "")
	}
	if r.excludePinnedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePinnedData", r.excludePinnedData, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue float32 = 100
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsIdActivatePostRequest struct {
	ctx        context.Context
	ApiService WorkflowAPI
	id         string
}

func (r WorkflowAPIWorkflowsIdActivatePostRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.WorkflowsIdActivatePostExecute(r)
}

/*
WorkflowsIdActivatePost Activate a workflow

Active a workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the workflow.
	@return WorkflowAPIWorkflowsIdActivatePostRequest
*/
func (a *WorkflowAPIService) WorkflowsIdActivatePost(ctx context.Context, id string) WorkflowAPIWorkflowsIdActivatePostRequest {
	return WorkflowAPIWorkflowsIdActivatePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Workflow
func (a *WorkflowAPIService) WorkflowsIdActivatePostExecute(r WorkflowAPIWorkflowsIdActivatePostRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsIdActivatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows/{id}/activate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsIdDeactivatePostRequest struct {
	ctx        context.Context
	ApiService WorkflowAPI
	id         string
}

func (r WorkflowAPIWorkflowsIdDeactivatePostRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.WorkflowsIdDeactivatePostExecute(r)
}

/*
WorkflowsIdDeactivatePost Deactivate a workflow

Deactivate a workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the workflow.
	@return WorkflowAPIWorkflowsIdDeactivatePostRequest
*/
func (a *WorkflowAPIService) WorkflowsIdDeactivatePost(ctx context.Context, id string) WorkflowAPIWorkflowsIdDeactivatePostRequest {
	return WorkflowAPIWorkflowsIdDeactivatePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Workflow
func (a *WorkflowAPIService) WorkflowsIdDeactivatePostExecute(r WorkflowAPIWorkflowsIdDeactivatePostRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsIdDeactivatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows/{id}/deactivate"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsIdDeleteRequest struct {
	ctx        context.Context
	ApiService WorkflowAPI
	id         string
}

func (r WorkflowAPIWorkflowsIdDeleteRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.WorkflowsIdDeleteExecute(r)
}

/*
WorkflowsIdDelete Delete a workflow

Deletes a workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the workflow.
	@return WorkflowAPIWorkflowsIdDeleteRequest
*/
func (a *WorkflowAPIService) WorkflowsIdDelete(ctx context.Context, id string) WorkflowAPIWorkflowsIdDeleteRequest {
	return WorkflowAPIWorkflowsIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Workflow
func (a *WorkflowAPIService) WorkflowsIdDeleteExecute(r WorkflowAPIWorkflowsIdDeleteRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsIdGetRequest struct {
	ctx               context.Context
	ApiService        WorkflowAPI
	id                string
	excludePinnedData *bool
}

// Set this to avoid retrieving pinned data
func (r WorkflowAPIWorkflowsIdGetRequest) ExcludePinnedData(excludePinnedData bool) WorkflowAPIWorkflowsIdGetRequest {
	r.excludePinnedData = &excludePinnedData
	return r
}

func (r WorkflowAPIWorkflowsIdGetRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.WorkflowsIdGetExecute(r)
}

/*
WorkflowsIdGet Retrieves a workflow

Retrieves a workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the workflow.
	@return WorkflowAPIWorkflowsIdGetRequest
*/
func (a *WorkflowAPIService) WorkflowsIdGet(ctx context.Context, id string) WorkflowAPIWorkflowsIdGetRequest {
	return WorkflowAPIWorkflowsIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Workflow
func (a *WorkflowAPIService) WorkflowsIdGetExecute(r WorkflowAPIWorkflowsIdGetRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludePinnedData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludePinnedData", r.excludePinnedData, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsIdPutRequest struct {
	ctx        context.Context
	ApiService WorkflowAPI
	id         string
	workflow   *Workflow
}

// Updated workflow object.
func (r WorkflowAPIWorkflowsIdPutRequest) Workflow(workflow Workflow) WorkflowAPIWorkflowsIdPutRequest {
	r.workflow = &workflow
	return r
}

func (r WorkflowAPIWorkflowsIdPutRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.WorkflowsIdPutExecute(r)
}

/*
WorkflowsIdPut Update a workflow

Update a workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the workflow.
	@return WorkflowAPIWorkflowsIdPutRequest
*/
func (a *WorkflowAPIService) WorkflowsIdPut(ctx context.Context, id string) WorkflowAPIWorkflowsIdPutRequest {
	return WorkflowAPIWorkflowsIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return Workflow
func (a *WorkflowAPIService) WorkflowsIdPutExecute(r WorkflowAPIWorkflowsIdPutRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsIdPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workflow == nil {
		return localVarReturnValue, nil, reportError("workflow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflow
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsIdTagsGetRequest struct {
	ctx        context.Context
	ApiService WorkflowAPI
	id         string
}

func (r WorkflowAPIWorkflowsIdTagsGetRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.WorkflowsIdTagsGetExecute(r)
}

/*
WorkflowsIdTagsGet Get workflow tags

Get workflow tags.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the workflow.
	@return WorkflowAPIWorkflowsIdTagsGetRequest
*/
func (a *WorkflowAPIService) WorkflowsIdTagsGet(ctx context.Context, id string) WorkflowAPIWorkflowsIdTagsGetRequest {
	return WorkflowAPIWorkflowsIdTagsGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []Tag
func (a *WorkflowAPIService) WorkflowsIdTagsGetExecute(r WorkflowAPIWorkflowsIdTagsGetRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsIdTagsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows/{id}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsIdTagsPutRequest struct {
	ctx         context.Context
	ApiService  WorkflowAPI
	id          string
	tagIdsInner *[]TagIdsInner
}

// List of tags
func (r WorkflowAPIWorkflowsIdTagsPutRequest) TagIdsInner(tagIdsInner []TagIdsInner) WorkflowAPIWorkflowsIdTagsPutRequest {
	r.tagIdsInner = &tagIdsInner
	return r
}

func (r WorkflowAPIWorkflowsIdTagsPutRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.WorkflowsIdTagsPutExecute(r)
}

/*
WorkflowsIdTagsPut Update tags of a workflow

Update tags of a workflow.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the workflow.
	@return WorkflowAPIWorkflowsIdTagsPutRequest
*/
func (a *WorkflowAPIService) WorkflowsIdTagsPut(ctx context.Context, id string) WorkflowAPIWorkflowsIdTagsPutRequest {
	return WorkflowAPIWorkflowsIdTagsPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return []Tag
func (a *WorkflowAPIService) WorkflowsIdTagsPutExecute(r WorkflowAPIWorkflowsIdTagsPutRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsIdTagsPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows/{id}/tags"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.tagIdsInner == nil {
		return localVarReturnValue, nil, reportError("tagIdsInner is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tagIdsInner
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsIdTransferPutRequest struct {
	ctx                           context.Context
	ApiService                    WorkflowAPI
	id                            string
	workflowsIdTransferPutRequest *WorkflowsIdTransferPutRequest
}

// Destination project information for the workflow transfer.
func (r WorkflowAPIWorkflowsIdTransferPutRequest) WorkflowsIdTransferPutRequest(workflowsIdTransferPutRequest WorkflowsIdTransferPutRequest) WorkflowAPIWorkflowsIdTransferPutRequest {
	r.workflowsIdTransferPutRequest = &workflowsIdTransferPutRequest
	return r
}

func (r WorkflowAPIWorkflowsIdTransferPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.WorkflowsIdTransferPutExecute(r)
}

/*
WorkflowsIdTransferPut Transfer a workflow to another project.

Transfer a workflow to another project.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id The ID of the workflow.
	@return WorkflowAPIWorkflowsIdTransferPutRequest
*/
func (a *WorkflowAPIService) WorkflowsIdTransferPut(ctx context.Context, id string) WorkflowAPIWorkflowsIdTransferPutRequest {
	return WorkflowAPIWorkflowsIdTransferPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *WorkflowAPIService) WorkflowsIdTransferPutExecute(r WorkflowAPIWorkflowsIdTransferPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsIdTransferPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows/{id}/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workflowsIdTransferPutRequest == nil {
		return nil, reportError("workflowsIdTransferPutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflowsIdTransferPutRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type WorkflowAPIWorkflowsPostRequest struct {
	ctx        context.Context
	ApiService WorkflowAPI
	workflow   *Workflow
}

// Created workflow object.
func (r WorkflowAPIWorkflowsPostRequest) Workflow(workflow Workflow) WorkflowAPIWorkflowsPostRequest {
	r.workflow = &workflow
	return r
}

func (r WorkflowAPIWorkflowsPostRequest) Execute() (*Workflow, *http.Response, error) {
	return r.ApiService.WorkflowsPostExecute(r)
}

/*
WorkflowsPost Create a workflow

Create a workflow in your instance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return WorkflowAPIWorkflowsPostRequest
*/
func (a *WorkflowAPIService) WorkflowsPost(ctx context.Context) WorkflowAPIWorkflowsPostRequest {
	return WorkflowAPIWorkflowsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Workflow
func (a *WorkflowAPIService) WorkflowsPostExecute(r WorkflowAPIWorkflowsPostRequest) (*Workflow, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowAPIService.WorkflowsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflows"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.workflow == nil {
		return localVarReturnValue, nil, reportError("workflow is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.workflow
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-N8N-API-KEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
